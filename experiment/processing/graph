#!/usr/bin/env python2

# * if the configuration was eventually successful
# * total time to successful configuration
# * if failure, ultimate reason for failure
# * number of tries until success
# * causes for errors
# * if participants listened to our directions (ie choosing the next bridge, or anything on the error screen)
# * all paths taken through the interface

import datetime
import json
import re
import sys

class Record(object):
    def __init__(self, run_id, date, event):
        self.run_id = date
        self.date = date
        self.event = event

# src and dst are vertices; i.e. pages or states in the interface.
# via is a string indicating an action that moved you from src to dst.
# src and dst can be the same.
class Edge(object):
    def __init__(self, src, dst, via):
        self.src = src
        self.dst = dst
        self.via = via

def parse_date_string(s):
    m = re.match(r'^(.*)(\.\d\d\d)Z$', s)
    d = datetime.datetime.strptime(m.group(1), "%Y-%m-%dT%H:%M:%S")
    return d.replace(microsecond=int(float(m.group(2)) * 1000000))

# Returns a list of Records.
def parse_records(f):
    records = []
    for line in f:
        parts = line.strip().split(" ", 3)
        if parts[0] != "INST":
            continue
        run_id = parts[1]
        date = parse_date_string(parts[2])
        event = json.loads(parts[3])
        records.append(Record(run_id, date, event))
    return records

def is_event_wanted(event):
    if event["type"] in ("mouseover", "mouseout"):
        return False
    if event["type"] in ("popupshown", "popuphidden"):
        return False
    if event["type"] in ("pagehide", "pageadvanced", "pagerewound"):
        return False
    if event["type"] in ("load", "unload") and event["target_id"] == "configuration":
        return False
    if event["type"] in ("click", "command") and event["target_tagname"] in ("menuitem", "wizard"):
        return False
    if event["type"] == "command" and event["target_tagname"] == "button":
        return False
    return True

def get_id(event):
    if event["type"] == "start":
        return ""
    elif event["type"] in ("mouseover", "mouseout"):
        return event["value"]
    elif event["type"] == "select":
        return "%s.%s" % (event["target_id"], event["value"] or '""')
    elif event["type"] == "progresschanged" or (event["type"] == "click" and event["target_tagname"] == "menuitem"):
        return event["value"]
    elif event["type"] == "unload" and event["target_id"] == "progress_bar":
        return "finish"
    else:
        return event["target_id"]

def parse_inst_log(f):
    records = parse_records(f)
    # For now, assert that we have exactly one "start" event, in the first
    # record.
    assert len(records) > 0
    assert records[0].event["type"] == "start"
    for record in records[1:]:
        assert record.event["type"] != "start"

    records = [record for record in records if is_event_wanted(record.event)]

    edges = []

    current_state = "start"
    for r in records:
        if r.event["type"] in ("pageshow", "load", "unload"):
            current_state = get_id(r.event)
            # Change previous edge to point to this new state.
            edges[-1].dst = current_state
        else:
            e = Edge(current_state, current_state, ("%s %s" % (r.event["type"], get_id(r.event))).strip())
            edges.append(e)

    return edges

def quote(s):
    return '"' + re.sub(r'[\\"]', lambda m: "\\"+m.group(), s) + '"'

edges = parse_inst_log(sys.stdin)
print "digraph G {"
for e in edges:
    print "\t%s -> %s [label=%s]" % (e.src, e.dst, quote(e.via))
print "}"
