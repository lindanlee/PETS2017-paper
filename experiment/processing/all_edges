#!/usr/bin/env python

"""
This script generates a CSV with every edge/transition in the experiment.
"""

import collections
import csv
import datetime
import getopt
import os
import os.path
import re
import sys

import inst

# src and dst are vertices; i.e. pages or states in the interface.
# via is a string indicating an action that moved you from src to dst.
# src and dst can be the same.
Edge = collections.namedtuple('Edge', ['exec_id', 'timestamp', 'src', 'dst', 'event_type', 'event_target', 'event_value'])

def is_event_wanted(event):
    if event["type"] in ("mouseover", "mouseout"):
        return False
    if event["type"] in ("popupshown", "popuphidden"):
        return False
    if event["type"] in ("pagehide", "pageadvanced", "pagerewound"):
        return False
    if event["type"] in ("load") and event["target_id"] == "configuration":
        return False
    if event["type"] in ("click", "command") and event.get("target_tagname") in ("menuitem", "wizard", None):
        return False
    if event["type"] == "command" and event["target_tagname"] == "button":
        return False
    return True

def get_id(event):
    """
    Canonicalizes event target
    """
    if event["type"] == "start":
        return "starting"
    elif event["type"] in ("mouseover", "mouseout"):
        return event["value"]
    elif event["type"] == "unload" and event["target_id"] == "configuration":
        return "not_running"
    else:
        return event["target_id"]

def parse_inst_log(f):
    records = inst.parse_records(f)
    # For now, assert that we have exactly one "start" event, in the first
    # record.
    assert len(records) > 0
    assert records[0].event["type"] == "start"
    #for record in records[1:]:
    #    assert record.event["type"] != "start"

    records = [record for record in records if is_event_wanted(record.event)]

    current_state = "not_running"
    edges = []

    for r in records:
        if r.event["type"] == "start":
            e = Edge(r.exec_id, r.date, current_state, current_state, r.event["type"], get_id(r.event), r.event.get("value", ""))
            edges.append(e)
            current_state = "starting"
        if r.event["type"] in ("start", "pageshow", "load", "unload"):
            current_state = get_id(r.event)
            # Change previous edge to point to this new state.
            edges[-1] = edges[-1]._replace(dst=current_state)
        else:
            e = Edge(r.exec_id, r.date, current_state, current_state, r.event["type"], get_id(r.event), r.event.get("value", ""))
            edges.append(e)

    return edges

log_filename = re.compile(r'(?P<env>E\d)-(?P<version>\w\w\w)-(?P<seat>X\d\d)-(?P<runid>\d{8}-\d{6})-inst.log$')

def main():
    _, filenames = getopt.gnu_getopt(sys.argv[1:], "")

    csvw = csv.DictWriter(sys.stdout, fieldnames=("seat", "runid", "exec_count", "sequence", "time_from_start", "time_from_last_edge", "src", "dst", "event_type", "event_target", "event_value"))
    csvw.writeheader()

    for filename in filenames:
        match = log_filename.match(os.path.basename(filename))
        if match is None:
            raise ValueError("cannot parse filename: {}".format(filename))

        with open(filename) as file:
            edges = parse_inst_log(file)

        if len(edges) > 0:
            start_date = edges[0].timestamp
            last_edge_date = edges[0].timestamp
        current_exec_id = None
        exec_count = 0
        sequence = 0
        for edge in edges:
            if edge.exec_id != current_exec_id:
                exec_count += 1
                current_exec_id = edge.exec_id
            sequence += 1
            time_from_start = (edge.timestamp - start_date).total_seconds()
            time_from_last_edge = (edge.timestamp - last_edge_date).total_seconds()
            fields = {
                "seat": match.group("seat"),
                "runid": match.group("runid"),
                "exec_count": exec_count,
                "sequence": sequence,
                "time_from_start": "%.1f" % time_from_start,
                "time_from_last_edge": "%.1f" % time_from_last_edge,
                "src": edge.src,
                "dst": edge.dst,
                "event_type": edge.event_type,
                "event_target": edge.event_target,
                "event_value": edge.event_value,
            }
            csvw.writerow(fields)
            last_edge_date = edge.timestamp

if __name__ == '__main__':
    main()
